---
draft: false
aliases: ["/fa/"]
---

# کامیت های قراردادی 1.0.0

## خلاصه

مشخصه های کامیت های قرار دادی‌ ، قراردادی سبک روی پیام های کامیت هستند.
قوانینی آسان برای مشخص کردن واضح تاریخچه کامیت ها تعیین میکند.
که باعث اسان تر شدن نوشتن ابزار های خودکار برای انها میشود و این قرارداد به [SemVer](http://semver.org) به علت شرح دادن قابلیت ها ، اصلاحات و تغییرات عمده در پیام های کامیت ها ، هماهنگ است.

پیام های کامیت ها باید طبق ساختار زیر باشند:


---

```

<نوع>[اختیاری محدوده]: <توضیحات>

[بدنه اختیاری]

[اختیاری پاورقی(ها)]
```
---

<br />
            
کامیت شامل عناصر ساختاری زیر برای ارتباط استفاده کننده از کتاب خانه شماست:   
 
1. **fix:**

 یک کامیت از *نوع* `اصلاح` که یک باگ را از کد شما برطرف میکند (با  [`MINOR`](http://semver.org/#summary) در نسخه‌بندی معنایی همخوانی دارد ).

2. **feat:**        

یک کامیت از *نوع* `قابلیت` که یک قابلیت جدید را که به کد شما اضافه شده را نشان میدهد (با [`PATCH`](http://semver.org/#summary) در نسخه‌بندی معنایی همخوانی دارد ).

3. **BREAKING CHANGE:**

کامیتی که پاورقی `تغییر عمده:` را دارد , یا یک `!` را بعد از نوع/محدوده آن اضافه می کند که یک تغییر عمده در ‌API را نشان میدهد (با  [`MAJOR`](http://semver.org/#summary) در نسخه‌بندی معنایی همخوانی دارد ). این نوع کامیت می تواند بخشی از هر *نوع* کامیتی باشد.
   
4. 
نوع کامیت هایی غیر از `fix:` و `feat:` که مجاز هستند, برای مثال:      

[@commitlint/config-conventional](https://github.com/conventional-changelog/commitlint/tree/master/%40commitlint/config-conventional) (based on the [Angular convention](https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines))          

کامیت هایی از نوع:

 `build:`, `chore:`,`ci:`, `docs:`, `style:`, `refactor:`, `perf:`, `test:`       

و بقیه ی انواع را پیشنهاد می دهد.

 5.
 
کامیت های نوع *پاورقی* ممکن است غیر از کامیت های نوع `تغییرات عمده : <توضیحات>` ایجاد شود و از قراردادی شبیه به [فرمت گیت](https://git-scm.com/docs/git-interpret-trailers) تبعیت کند.    


نوع های دیگر برای مشخصه های کامیت های قراردادی اجباری نیستند و هیج تاثیر ضمنی در نسخه‌بندی معنایی ندارند (مگر شامل کامیتی از نوع تغییرات عمده باشند).
<br /><br />
ممکن است محدوده ای برای نوع کامیت برای اطلاعات متنی بیشتر اورده شود که شامل پرانتز است, مثل 

`feat(parser): add ability to parse arrays`      

## نمونه ها 

### پیام کامیت با توضیحات و پاورقی تغییرات عمده

```
feat: allow provided config object to extend other configs

BREAKING CHANGE: `extends` key in config file is now used for extending other config files
```

### پیام کامیت با علامت `!` برای جلب توجه و نشان دادن تغییرات عمده
```
feat!: send an email to the customer when a product is shipped
```

### پیام کامیت با محدوده و علامت `!` برای جلب توجه و نشان دادن تغییرات عمده 

```
feat(api)!: send an email to the customer when a product is shipped
```

### پیام کامیت همراه `!` و پاورقی تغییرات عمده 

```
chore!: drop support for Node 6

BREAKING CHANGE: use JavaScript features not available in Node 6.
```

### پیام کامیت بدون بدنه

```
docs: correct spelling of CHANGELOG
```

### پیام کامیت با محدوده
```
feat(lang): add Polish language
```

### پیام کامیت با چند پاراگراف بدنه و چند پاورقی

```
fix: prevent racing of requests

Introduce a request id and a reference to latest request. Dismiss
incoming responses other than from latest request.

Remove timeouts which were used to mitigate the racing issue but are
obsolete now.

Reviewed-by: Z
Refs: #123
```

## مشخصه ها

کلید واژه های      

 “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, و “OPTIONAL”       
 
 در این مقاله به شرح [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt) تفسیر میشوند. 

۱.  کامیت ها باید پیشوندی از نوع کامیت مشخص داشته باشند که شامل اسم هایی مثل `feat`, `fix` باشد و همراه با محدوده اختیاری , `!` اختیاری , و نیازمند ستون و فضای ترمینال می باشد.

۲.  نوع `feat` باید زمانی استفاده شود که کامیت قابلیت جدیدی به کتاب خانه یا برنامه شما اضافه میکند.     
۳.  نوع `fix` زمانی باید استفاده شود که کامیت نشان دهنده اصلاح یک باگ از برنامه شماست.        

۴.  یک محدوده ممکن است بعد از یک نوع کامیت بیاید. یک محدوده باید شامل یک اسم باشد که توصیف کننده بخشی از کد است و با پرانتز مشخص میشود مثل:      
`fix(parser):`           

۵.  یک توضیح بعد از نوع/محدوده پیشوند باید بلافاصله ستون و فضا را دنبال کند.توضیح یک خلاصه مختصر از تغییرات در کد است مثل:        
  _fix: array parsing issue when multiple spaces were contained in string_        
  
۶.  بدنه یک کامیت طولانی ممکن است بعد از یک توضیح مختصر بیاید و توضیحات متنی بیشتری راجع تغییرات کد ارائه دهد. بدنه حتما باید در شروعش یک خط خالی بعد از توضیحات داشته باشد.     

۷.  بدنه یک کامیت فرم آزادی دارد و ممکن است شامل هر تعداد خط جدید و پاراگراف شود.

۸.  یک یا چند پاورقی ممکن است همراه یک خط خالی بعد از بدنه اورده شوند هر پاورقی حتما باید شامل یک کلمه نشانه ای و همچنین `<space>:` یا `#<space>` به عنوان جدا کننده باشد و همراه یک مقدار استرینگ باشد.(الهام گرفته شده از [فرمت گیت](https://git-scm.com/docs/git-interpret-trailers))       

۹.  نشانه پاورقی باید از `-` به جای اسپیس استفاده شود مثل:         
 `Acked-by` 
( این به تمایز بین پاورقی پاراگراف بنده چند خطی کمک میکند)          
یک استثنا برای کامیت های نوع `تغییرات عمده` وجود دارد که ممکن است به عنوان نشانه استفاده شود.      

۱۰.  یک پاورقی ممکن است شامل اسپیس یا خط خالی شود و جدا کننده باید هنگام رسیدن به نشانه/جداکننده اجرا شود.     

۱۱.  تغییرات عمده باید حتما در نوع/محدوده پیشوند کامیت نشان داده شده یا یک ورودی در پاورقی باشد.

۱۲.  اگر به عنوان یک پاورقی اضافه گردد تغییرات عمده باید حتما شامل متن بزرگ 
BREAKING CHANGE
همراه با دو نقطه باشد و اسپیس و توضیحات باشد مثل 
_BREAKING CHANGE: environment variables now take precedence 
over config files_.

 1. اگر شامل پیشوند نوع/محدوده باشد تغییرات عمده باید حتما با `!` بلا فاصله بعد از  `:` نشان داده شود. اگر `!` استفاده شد `تغییرات عمده `ممکن است از بخش پاورقی حذف شود و توضیحات کامیت بهتر است توضیح دهنده تغییرات عمده باشد 
1. نوع ها غیر از `feat` و `fix` نیز ممکن است در پیام کامیت ها استفاده شوند مثل 
_docs: update ref docs._

1. پیاده ساز ها نباید واحد های اطلاعات که کامیت های قرار دادی را شامل آنها میشوند به بزرگ و کوچک حساس باشند به غیر از تغییرات عمده که همواره باید همیشه بزرگ باشند 

1. همگام استفاده به عنوان نشانه در پاورقی تغییرات-عمده همواره باید معادل تغییرات عمده باشند 

## چرایی استفاده از کامیت های قراردادی 

* ساختن لاگ تغییرات خودکار
* تغیین کردن نسخه‌بندی معنایی به صورت خودکار
* انتقال ماهیت تغییرات به هم تیمی ها، مردم و سایر ذینفعان.

* راه اندازی فرآیندهای ساخت و انتشار.
* اسان کردن مشارکت مردم در پروژه های شما با اجازه دادن به آنها برای برسی تاریخچه کامیت با ساختار مشخص تر.

## پرسشگان

### چگونه باید با پیام کامیت ها در ابتدای فاز توسعه کنار بیایم؟

ما توصیه میکنیم اگر قبلا محصول را عرضه کرده اید ادامه دهید . به طور نمونه هر کسی حتی اگر او همکار شما در توسعه نرم افزار باشد که از نرم افزار استفاده میکند خواهد دانست که چه چیزی اصلاح شده و چه چیزی خراب شده است و غیره .




### آیا نوع تایتل کامیت باید بزرگ باشد یا کوچک ؟
هر مدلی ممکن است استفاده شود ولی بهتر است که متسمر باشد.


### اگر کامیت شامل بیش از یک نوع کامیت میشد چه کار کنم ؟
تا جای ممکن به عقب برگردید و چند کامیت انجام دهید. بخشی از مزایای کامیت قراردادی امکان هدایت ما به کامیت ها و پول رکوئست های ساختارمند تر است.



### ایا این کار باعث دلسرد شدن از توسعه سریع نمیشود؟
این کار باعث دلسرد شدن از پیشرفت بدون ساختار میشود.
و کمک میکند به شما تا بتوانید به صورت بلند مدت در میان چند پروژه با مشارکت کنندگان زیاد سریع پیشرفت کنید. 


### ایا ممکن است کامیت های قرار دادی توسعه دهندگان را به سمت محدودیت نوع کامیت هدایت کند زیرا آنها دغدغه این را دارند که چه نوعی تغییر ایجاد میکنند؟ 
کامیت های قراردادی مارا بیشتر به نوع کامیت های مشخص تشویق میکند مثل اصلاح . غیر از آن انعطاف پذیری کامیت های قراردادی به تیم ما اجازه میدهد تا با نوع کامیت های خود کار کنند و انها را در طول زمان تغییر دهند.


###  کامیت های قرار دادی با نسخه‌بندی معنایی چگونه ارتباط دارند؟ 


`fix`
 نوعی است که به 
 `PATCH`
  ترجمه میشود 
  . `feat`
   نوعی است که بهتر از به 
   `MINOR` ترجمه شود .
    کامیت هایی با 
     `تغییرات عمده`
     بدون توجه به نوع تغییر به  
      `MAJOR` 
      معادل میشوند.

### چگونه باید ورژن نسخه مشخصه های کامیت های قرار دادی مثل  `@jameswomack/conventional-commit-spec` را انجام دهم
ما توصیه میکنیم از نسخه‌بندی معنایی برای ریلیز نسخه های خود استفاده کنید.



### باید چه کار کنم اگر از نوع اشتباهی از کامیت استفاده کردم؟


#### همگامی که شما از نوعی که مشخص است ولی صحیح نیست مثل 
`fix`
 به جای
  `feat`

قبل از مرج یا ریلیز کردن اشتباه توصیه میکنیم که از 
`git rebase -i`
برای ادیت تاریخچه کامیت ها استفاده کنید. بعد از ریلیز پاکسازی با توجه به رویکرد شما که چه فرایند یا ابزاری استفاده میکنید متفاوت خواهد بود.

#### زمانی که شما غلط املایی دارید مثل `feet` 
به جای 
`feat`

در بدترین حالت  اخر دنیا نمیشود اگر که یک کامیت طبق مشخصه کامیت های قرار دادی نباشد بلکه تنها معنی آن از زیر دست ابزاری که بر اساس مشخصه کامیت های قرار دادی است در میرود 


### ایا همه مشارکت کنندگان من باید از مشخصه کامیت های قراردادی استفاده کنند؟
نه اگر ورک فلو گیت شما بر اساس
 squash
 باشد نگه دارندگان مخزن های گیت میتوانند انها را اصلاح کنند.
 یک ورک فلو معمولی برای این کار هنگامی است که به صورت خودکار کامیت های پول رکوئست 
  squash
میشوند و نگه دارندگان مخزن گیت میتوانند با پیام مناسب آن را با مخزن اصلی ادغام کنند 


### کامیت های قرار دادی چگونه برگشت کامیت ها را مدیریت میکنند

برگشت کد ممکن است پیچیده باشد: ایا چند کامیت را بر میگردانید؟ اگر یک قابلیت را بر میگردانید ریلیز بعدی باید یک اصلاح باشد؟
کامیت های قرار دادی به صورت صریح تلاش نمیکنند که یک رفتار بازگشتی را تبعیین ککند بلکه ان را به ابزار های نویسنده واگزار میکنیم تا با انعطاف _نوع_ و _پاورقی_ منطق بازگشت را مدیریت کنند.

یک توصیه آن است که از نوع `بازگشت` استفاده کنید و پاورقی آن هش کامیت رفرنس باشد: 


```
revert: let us never again speak of the noodle incident

Refs: 676104e, a215868
```

